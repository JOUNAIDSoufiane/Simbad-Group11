//--------------------------------------------------------
//Code generated by Papyrus Java
//--------------------------------------------------------

package main.java.softdesign;

import java.awt.image.BufferedImage;
import javax.vecmath.Vector3d;
import simbad.sim.RangeSensorBelt;

/************************************************************/
/**
* 
*/
public class CentralStation {
	/**
	 * 
	 */
	private Robot[] robots;
	/**
	 * 
	 */
	private static CentralStation centralStation = new CentralStation();
	/**
	 * 
	 */
	private static String[] behaviorPatterns;
	/**
	 * 
	 */
	private FileServer fileServer;
	/**
	 * 
	 */
	private Coordinates[] startingPositions;
	/**
	 * 
	 */
	private Color goalColor;
	/**
	 * Start mission sets the goal color given by the user and sets the robots on the search
	 * @param color  
	 */
	public void startMission(Color color) {
		robots[0].setBehavior(behaviorPatterns[0]);
		robots[1].setBehavior(behaviorPatterns[0]);
		goalColor = color; 
	}
	/**
	 * 
	 * @param robot
	 * @param sonars
	 * 
	 * Coordinates all possible encounters with objects and walls
	 */
	public void foundObstacle(Robot robot, RangeSensorBelt sonars){
		
		// Hitting dead end 
		if (sonars.hasHit(2) && sonars.hasHit(6) && sonars.hasHit(0)){
			// If there's no space on either side, turn around
			if (sonars.getMeasurement(6) < 0.5 && sonars.getMeasurement(2) < 0.5)
				robot.turnAround();
			// If enough space on right, turn right
			else if (sonars.getMeasurement(6) > 0.5)
				robot.turnRight();
			// If enough space on left, turn left
			else if (sonars.getMeasurement(2) > 0.5)
				robot.turnLeft();
		}
		// When left is blocked, turn right
		else if (sonars.hasHit(2) && !sonars.hasHit(6)){
			robot.turnRight();
		}
		// When right is blocked, turn left
		else if (!sonars.hasHit(2) && sonars.hasHit(6)){
			robot.turnLeft();
		}
		// When front is blocked
		else if (!sonars.hasHit(2) && !sonars.hasHit(6)){	
			/*	    _________
			 * 	   |
			 * 	    O
			 * 	   |			turns right before wall
			 */
			if(sonars.hasHit(1) && !sonars.hasHit(4))
				robot.turnRight();
			/*  _________
			 *    	     |
			 *  	    O	
			 * 	    	 |		turns left before wall
			 */
			else if(sonars.hasHit(7) && !sonars.hasHit(4))
				robot.turnLeft();
			// When front left is blocked, turn right (there's a gap in the wall on the front right)
			else if(sonars.hasHit(1) && !sonars.hasHit(7))
				robot.turnRight();
			// When front right is blocked, turn left (there's a gap in the wall on the front left)
			else if(sonars.hasHit(7) && !sonars.hasHit(1))
				robot.turnLeft();
		}
	}
	/**
	 * CentralStation Constructor
	 */
	private CentralStation() {
		// MAX ROBOTS = 2 
		robots = new Robot[2]; 
		
		startingPositions = new Coordinates[2];
		
		behaviorPatterns = new String[5];
		behaviorPatterns[0] = "followWall";
		behaviorPatterns[1] = "spiral";
		behaviorPatterns[2] = "stop";
		behaviorPatterns[3] = "aroundObstacle";
		behaviorPatterns[4] = "moveTo";
		
		fileServer = FileServer.getInstance();
	}
	
	/**
	 * Stops mission and returns the findings
	 */
	public void doneMapping() {
		robots[0].stop();
		robots[1].stop();
		robots[0].setBehavior(behaviorPatterns[2]);
		robots[1].setBehavior(behaviorPatterns[2]);
		fileServer.count();
		fileServer.foundObject(goalColor);
	}
	/**
	 * @return
	 */
	public static CentralStation getInstance() {
		return centralStation;
	}
	/**
	 * 
	 * @param position
	 * @param name
	 * @return
	 */
	public Robot deployRobot(Vector3d position, String name) {
		// Parse name to find robot's number
		int robotsNumber = Integer.parseInt(name.replaceAll("\\D", ""));
	
		robots[robotsNumber - 1] = new Robot(position, name);
		robots[robotsNumber - 1].initBehavior();

		// Store robot's position
		startingPositions[robotsNumber - 1] = new Coordinates(position.x, position.z);
		
		// Remove the robot's current position 
		fileServer.removeCoordinates(new Coordinates(position.x, position.z));
		return robots[robotsNumber - 1];
	}
	/**
	 * 
	 * @param coordinates
	 * @param prevCoordinates
	 * @return
	 * 
	 * Checks if Coordinates to the left behind the robot are an Objects' coordinates
	 * To get the left coordinates behind the robot, it gets the right coordinates of the robot's inverted travel direction
	 */
	public boolean isObject(Coordinates coordinates, Coordinates prevCoordinates) {
		Coordinates right;
		
		// If inverted travel direction is going up the x-axis (towards higher x-values), the right coordinate is 0.5 added to y
		if(coordinates.x - prevCoordinates.x > 0) 
			right =  new Coordinates(prevCoordinates.x, prevCoordinates.y + 0.5);
		
		//  If inverted travel direction is going down the x-axis (towards lower x-values), the right coordinate is 0.5 subtracted from y
		else if(coordinates.x - prevCoordinates.x < 0)
			right =  new Coordinates(prevCoordinates.x, prevCoordinates.y - 0.5);
		
		// If inverted travel direction is going up the y-axis (towards higher y-values), the right coordinate is 0.5 subtracted from x
		else if(coordinates.y - prevCoordinates.y > 0)
			right =  new Coordinates(prevCoordinates.x - 0.5, prevCoordinates.y);
		
		// If inverted travel direction is going down the y-axis (towards lower y-values), the right coordinate is 0.5 added to x
		else
			right = new Coordinates(prevCoordinates.x + 0.5, prevCoordinates.y);
		
		return fileServer.isObject(right);
	}
	/**
	 * 
	 * @param coordinates 
	 * @return
	 * 
	 * Checks to see if any robot has reached another robot's starting coordinates
	 */
	public boolean reachedStartingPositions(Coordinates coordinates) {
		for(int i = 0; i < startingPositions.length; i++){
			if(coordinates.x == startingPositions[i].x && coordinates.y == startingPositions[i].y)
				return true;
		}
		return false;
	}
	/**
	 * 
	 * @param robot
	 * @param coordinates
	 * @param prevCoordinates
	 * 
	 * Guides the robot in an inward spiraling motion
	 */
	public void spiral(Robot robot, Coordinates coordinates, Coordinates prevCoordinates) {
		
		Coordinates nextCoordinates = getNextCoordinates(coordinates, prevCoordinates), left = getLeftCoordinates(coordinates, prevCoordinates);
		
		// If all coordinates around the robot at the current coordinate have been visited, a different behavior pattern will be loaded.
		if(fileServer.visited(new Coordinates(coordinates.x + 0.5, coordinates.y)) && fileServer.visited(new Coordinates(coordinates.x - 0.5, coordinates.y)) 
				&& fileServer.visited(new Coordinates(coordinates.x, coordinates.y + 0.5)) && fileServer.visited(new Coordinates(coordinates.x, coordinates.y - 0.5)))
			coverUnvisited();
		
		/** 
		*  The robot will move straight until either of the following conditions are met.
		*/
		else {
			if (!fileServer.visited(left))
				robot.turnLeft();
			else if (fileServer.visited(nextCoordinates))
				robot.turnRight();
		}
	}
	/**
	 * 
	 * @param coordinates
	 * @param prevCoordinates
	 * 
	 * Stores blocked coordinates, which are not accessible to the robot, on the file server
	 */
	public void addBlocked(Coordinates coordinates, Coordinates prevCoordinates) {
		fileServer.addBlocked(getLeftCoordinates(coordinates, prevCoordinates));
	}
	/**
	 * 
	 * Finds remaining unvisited coordinates after first round of spirals and instructs the robots to drive towards those coordinates
	 */
	public void coverUnvisited() {
		// Remove all unvisited coordinates that don't have any adjacent unvisited coordinates, since objects need to occupy at least 2 adjacent coordinates
		for(double i = -12; i <= 12; i+=0.5) {
			for(double j = -12; j <= 12; j+=0.5) {
				Coordinates coordinates = new Coordinates(i,j);
				if(!fileServer.visited(coordinates)) {
					if(fileServer.visited(new Coordinates(i + 0.5, j)) && fileServer.visited(new Coordinates(i - 0.5, j)))
						fileServer.removeCoordinates(coordinates);
					else if(fileServer.visited(new Coordinates(i, j + 0.5)) && fileServer.visited(new Coordinates(i, j - 0.5)))
						fileServer.removeCoordinates(coordinates);
				}
			}
		}
		outerloop:
		for(double i = -12.5; i <= 12.5; i+=0.5) {  
			for(double j = -12.5; j <= 12.5; j+=0.5) {
				Coordinates coordinates = new Coordinates(i,j);
				if(!fileServer.visited(coordinates)) {
					robots[1].setGoal(coordinates);		
					robots[1].setBehavior(behaviorPatterns[4]);
					robots[0].setGoal(coordinates);
					robots[0].setBehavior(behaviorPatterns[4]);
					break outerloop;
				}
			}
			if(i == 12) {
				System.out.println("Finished Mapping Environment.");
				doneMapping();
			}
		}
	}
	/**
	 * 
	 * @param coordinates
	 * @param goal
	 * @return
	 * 
	 * Checks if there is a blocked coordinate between robot and goal coordinate on x axis
	 */
	public boolean nothingBetween(Coordinates coordinates, Coordinates goal) {
		if(coordinates.y < goal.y) {
			for(double i = coordinates.y + 0.5; i < goal.y; i+=0.5) {
				if(fileServer.isblocked(new Coordinates(coordinates.x, i)))
					return false;
			}
		} else if(coordinates.y > goal.y) {
			for(double i = coordinates.y - 0.5; i > goal.y; i-=0.5) {
				if(fileServer.isblocked(new Coordinates(coordinates.x, i)))
					return false;
			}
		}
		
		return true;
	}
	/**
	 * 
	 * @param coordinates
	 * 
	 * Marks coordinates as visited on file server
	 */
	public void updateCoordinates(Coordinates coordinates) {
		fileServer.removeCoordinates(coordinates);
	}
	/**
	 * 
	 * @param coordinates
	 * @param prevCoordinates
	 * @return
	 * 
	 * Calculates coordinates to left of robot using the robot's current and previous coordinates for calculating its travel direction
	 */
	private Coordinates getLeftCoordinates(Coordinates coordinates, Coordinates prevCoordinates) {
		
		// If robot's direction is going up the x-axis (towards higher x-values), the robot's left coordinate is 0.5 subtracted from y
		if(coordinates.x - prevCoordinates.x > 0) 
			return new Coordinates(coordinates.x, coordinates.y - 0.5);
		// If robot's direction is going down the x-axis (towards lower x-values), the robot's left coordinate is 0.5 added to y
		else if(coordinates.x - prevCoordinates.x < 0)
			return new Coordinates(coordinates.x, coordinates.y + 0.5);
		// If robot's direction is going up the y-axis (towards higher y-values), the robot's left coordinate is 0.5 added to x
		else if(coordinates.y - prevCoordinates.y > 0)
			return new Coordinates(coordinates.x + 0.5, coordinates.y);
		/*
		 *  Only possibility left, therefore no if statement needed
		 *  If robot's direction is going down the y-axis (towards lower y-values), the robot's left coordinate is 0.5 subtracted from x
		 */
		else
			return new Coordinates(coordinates.x - 0.5, coordinates.y);
		
	}
	/**
	 * 
	 * @param coordinates
	 * @param prevCoordinates
	 * @return
	 * 
	 * Calculates coordinates in front of robot
	 * (Logic works in the same way as previously mentioned in getLeftCoordinates, only calculation differs, since the coordinates in front
	 * of the robot are calculated instead of the left coordinates)
	 */
	private Coordinates getNextCoordinates(Coordinates coordinates, Coordinates prevCoordinates) {
	
		if(coordinates.x - prevCoordinates.x > 0)
			return new Coordinates(coordinates.x + 0.5, coordinates.y);
		else if(coordinates.x - prevCoordinates.x < 0)
			return new Coordinates(coordinates.x - 0.5, coordinates.y);
		else if(coordinates.y - prevCoordinates.y > 0)
			return new Coordinates(coordinates.x, coordinates.y + 0.5);
		else
			return new Coordinates(coordinates.x, coordinates.y - 0.5);
		
	}
	/**
	 * 
	 * @param coordinates
	 * @param prevCoordinates
	 * 
	 * Marks the next two coordinates to left of robot as visited (since walls cover 2 coordinates and robot is 1 coordinate from wall)
	 * (Logic for getting leftOfLeft coordinates works in the same way as previously mentioned in getLeftCoordinates, only calculation 
	 *  differs, since the coordinates to the left of the robot's left coordinates are calculated instead of the left coordinates)
	 */
	public void removeLeftCoordinates(Coordinates coordinates, Coordinates prevCoordinates) {
		Coordinates left = getLeftCoordinates(coordinates, prevCoordinates), leftOfLeft;
		
		if(coordinates.x - prevCoordinates.x > 0)
			leftOfLeft = new Coordinates(coordinates.x, coordinates.y - 1.0);
		else if(coordinates.x - prevCoordinates.x < 0)
			leftOfLeft = new Coordinates(coordinates.x, coordinates.y + 1.0);
		else if(coordinates.y - prevCoordinates.y > 0)
			leftOfLeft = new Coordinates(coordinates.x + 1.0, coordinates.y);
		else
			leftOfLeft = new Coordinates(coordinates.x - 1.0, coordinates.y);
			
		fileServer.removeCoordinates(left);
		
		// To not go out of bounds for removing coordinates on the outermost walls
		if(leftOfLeft.x >= -12.5 && leftOfLeft.x <= 12.5 && leftOfLeft.y >= -12.5 && leftOfLeft.y <= 12.5 )
			fileServer.removeCoordinates(leftOfLeft);
	}
	/**
	 * 
	 * @param coordinates
	 * @param cameraImage
	 * 
	 * Maps objects by calculating all coordinates it's covering and getting the color of the object 
	 * Stores object data on the file server
	 */
	public void mapObject(Coordinates[] coordinates, BufferedImage cameraImage) {
		
		/**   OBJECT IN INVERTED SIMBAD AXIS (Origin,(vector) y, (vector) x)
		*
		*      x  _______
		*        |       | 
		*        | Object| length  
		*        |       |
		* origin |_______| y 
		*          width
		*/
		Coordinates origin = coordinates[0], x = new Coordinates(0,0), y = new Coordinates(0,0);
		double length = 0, width = 0;
		int directionx, directiony;
		
		for (int i = 1; i < 4; i++) {
			if(origin.x == coordinates[i].x) {
				x = coordinates[i];
				length = Math.abs(Math.abs(origin.y) - Math.abs(x.y));
			}
			if(origin.y == coordinates[i].y) {
				y = coordinates[i];
				width = Math.abs(Math.abs(origin.x) - Math.abs(y.x));
			}
		}
		
		// Find the direction in which the object's coordinates were mapped for both axes to calculate the correct coordinates
		
		directiony = origin.y > x.y ? -1 : 1;
		directionx = origin.x > y.x ? -1 : 1;
		
		Object object = new Object();
		
		Coordinates center = new Coordinates((coordinates[0].x + coordinates[1].x +coordinates[2].x +coordinates[3].x)/4,
				(coordinates[0].y + coordinates[1].y +coordinates[2].y +coordinates[3].y)/4);
		
		// Removing the coordinates occupied by the object from the unvisited array, adding them to the blocked array, and adding them to the object's coordinates
		for (double i = 0; i <= width; i+= 0.5){
			for (double j = 0; j <= length; j+=0.5){
				Coordinates newCoordinates = new Coordinates(origin.x +i * directionx, origin.y + j * directiony);
				fileServer.removeCoordinates(newCoordinates);
				fileServer.addBlocked(newCoordinates);
				object.addCoordinates(newCoordinates);
			}
		}
		
		object.setColor(getColor(cameraImage));
		object.addCoordinates(center);

		fileServer.addObject(object);
	}
	/**
	 * 
	 * @param cameraImage
	 * @return 
	 * 
	 * Analyzes the picture of the object and returns the object's color
	 */
	private Color getColor(BufferedImage cameraImage) {
		int rgbValue = cameraImage.getRGB(cameraImage.getHeight() - 1, cameraImage.getWidth()/2);
		
		int blue = rgbValue & 0xff;
		int green = (rgbValue & 0xff00) >> 8;
		int red = (rgbValue & 0xff0000) >> 16;
		
		return new Color(red,green,blue);
	}
	/**
	 * 
	 * @param robot
	 * @param coordinates
	 * @param prevCoordinates
	 * 
	 * Checks which coordinates around the robot are unvisited and turns robot in the according direction
	 * (Logic for getting right coordinates works in the same way as previously mentioned in getLeftCoordinates, only calculation 
	 *  differs, since the coordinates to the right of the robot are calculated instead of the left coordinates)
	 */
    public void isFree(Robot robot, Coordinates coordinates, Coordinates prevCoordinates) {
    	Coordinates left = getLeftCoordinates(coordinates, prevCoordinates);
    	Coordinates right;
    	
    	if(coordinates.x - prevCoordinates.x > 0) 
			right = new Coordinates(coordinates.x, coordinates.y + 0.5);
		else if(coordinates.x - prevCoordinates.x < 0)
			right = new Coordinates(coordinates.x, coordinates.y - 0.5);
		else if(coordinates.y - prevCoordinates.y > 0)
			right = new Coordinates(coordinates.x - 0.5, coordinates.y);
		else
			right = new Coordinates(coordinates.x + 0.5, coordinates.y);
    	
    	// Checks if the left or right coordinates of the robot are unvisited, then turns the robot the corresponding direction
    	if(!fileServer.visited(left))
    		robot.turnLeft();
    	else if(!fileServer.visited(right))
    		robot.turnRight();
    }
	/**
	 * 
	 */
	public void stopMission() {
		System.out.println("Mission Stopped.");
		doneMapping();
	}
};