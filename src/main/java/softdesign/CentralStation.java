//--------------------------------------------------------
//Code generated by Papyrus Java
//--------------------------------------------------------

package main.java.softdesign;

import java.awt.image.BufferedImage;
import javax.vecmath.Vector3d;

import simbad.sim.RangeSensorBelt;

/************************************************************/
/**
* 
*/
public class CentralStation {
	/**
	 * 
	 */
	private Robot[] robots;
	
	//variable to store distance robot in spiral is supposed to travel before turning
	private double Odometer_count = 0.0;
	
	//variable for robot in spiral to count right turns (distance to travel after every 2nd right turn will increase)
	private int right_turns = 0;
	
	//variable for robot in spiral to multiply the travel distance the robot needs before turning right
	private int distance_multiplier = 1;
	/**
	 * 
	 */
	private static CentralStation central_station = new CentralStation();
	/**
	 * 
	 */
	private static String[] behavior_patterns;
	/**
	 * 
	 */
	private FileServer file_server;
	/**
	 * 
	 */
	private Coordinates[] robots_positions;

	/**
	 * 
	 */
	public static CentralStation getinstance() {
		return central_station;
	}
	
	/**
	 * 
	 * @param position
	 * @param name
	 * @param count
	 */
	public Robot deploy_robot(Vector3d position, String name) {
		//parse name to find robot's number
		int robots_number = Integer.parseInt(name.replaceAll("\\D", ""));
		
		//check if coordinate has already been visited
		while (file_server.visited(new Coordinates(position.x, position.z))) {
			System.out.println("Coordinate already explored, moving Robot");
			
			//TODO implement a way to change position to a useful coordinate (for now it's just a number)
			position.x = 9;
		}
		
		//instantiate new robot and add it to the robots array
		robots[robots_number - 1] = new Robot(position, name);
		robots[robots_number - 1].initBehavior();
		
		//store robot's position
		robots_positions[robots_number - 1] = new Coordinates(position.x, position.z);
		
		//remove the robot's current position 
		file_server.remove_coordinates(new Coordinates(position.x, position.z));
		return robots[robots_number - 1];
	}
	
	/**
	 * 
	 * @param color 
	 * @param position_color_found 
	 */
	public Coordinates start_mission(Color color) {
		//TODO return target box (for now just dummy position)
		
		//Set each robot's behavior pattern
		robots[0].set_behavior(behavior_patterns[0]);
		
		//TODO might be new pattern
		robots[1].set_behavior(behavior_patterns[1]);
		
		return new Coordinates(0,0);
		
	}
	
	
	public void spiral_down(Robot robot, Coordinates coordinates, Coordinates prev) {
		Coordinates next_coordinates, xplus, xminus, yplus, yminus;
		
		xplus = new Coordinates(coordinates.x + 0.5, coordinates.y);
		xminus = new Coordinates(coordinates.x - 0.5, coordinates.y);
		yplus = new Coordinates(coordinates.x, coordinates.y + 0.5);
		yminus = new Coordinates(coordinates.x, coordinates.y - 0.5);
		
		if(file_server.visited(xplus) && file_server.visited(xminus) && file_server.visited(yplus) && file_server.visited(yminus)) {
			//If all coordinates around robot have been visited, stop robot
			robot.stop();
			robot.set_behavior(behavior_patterns[3]);
		}
		else {
			if(coordinates.x - prev.x > 0)
				next_coordinates = xplus;
			else if(coordinates.x - prev.x < 0)
				next_coordinates = xminus;
			else if(coordinates.y - prev.y > 0)
				next_coordinates = yplus;
			else
				next_coordinates = yminus;
			
			if (file_server.visited(next_coordinates))
					robot.turn_right();
		}
	}
	
	
	/**
	 * 
	 * @param robot
	 * @param position
	 */
	public void update_coordinates(Robot robot, Coordinates coordinates) {
		
		if (!file_server.visited(coordinates)) {
			file_server.remove_coordinates(coordinates);
			System.out.println("I am " + robot.get_name() + " and I am at coordinate " + coordinates.x + "," + coordinates.y);
		} 
				
	}
	/**
	 * 
	 * @param coordinates 
	 * @param color 
	 * @return 
	 */
	public boolean found_object(Coordinates coordinates, BufferedImage cameraImage) {
		
		int color = cameraImage.getRGB(cameraImage.getHeight()/2, cameraImage.getWidth()/2);
		int blue = color & 0xff;
		int green = (color & 0xff00) >> 8;
		int red = (color & 0xff0000) >> 16;
		
	 	if(red > 250 && green < 50 && blue < 50) //these values are used to truly find red and not black
		{
			System.out.println("Picture taken " + red);
			return true;
		}
		
		else
		{
			return false;
		}
	
		
	}
	
	public void found_obstacle(Robot robot, RangeSensorBelt sonars){
		
		//Stop spiral robot if it encounters an object TODO implement what to do when spiral encounters object or wall
		if(sonars.hasHit(0) && sonars.getMeasurement(0) < 0.5 && robot.get_behavior() == "spiral") {
			robot.stop();
			//TODO Set next behavior of robot (currently stops)
			robot.set_behavior(behavior_patterns[3]);
		}
		
		//TODO Implement call to foundCube when encountering box (Object mapping)
		
		//Hitting dead end 
		else if (sonars.hasHit(2) && sonars.hasHit(6) && sonars.hasHit(0)){
			//If there's no space on either side, turn around
			if (sonars.getMeasurement(6) < 0.5 && sonars.getMeasurement(2) < 0.5)
				robot.turn_around();
			//if enough space on right, turn right
			else if (sonars.getMeasurement(6) > 0.5)
				robot.turn_right();
			//if enough space on left, turn left
			else if (sonars.getMeasurement(2) > 0.5)
				robot.turn_left();
		}
		//When left is blocked, turn right
		else if (sonars.hasHit(2) && !sonars.hasHit(6)){
			robot.turn_right();
		}
		//When right is blocked, turn left
		else if (!sonars.hasHit(2) && sonars.hasHit(6)){
			robot.turn_left();
		}
		//When front is blocked
		else if (!sonars.hasHit(2) && !sonars.hasHit(6))
		{	
			
			/*	    _________
			 * 	   |
			 * 	    O
			 * 	   |			turns right before wall
			 */
			if(sonars.hasHit(1) && !sonars.hasHit(4))
				robot.turn_right();
			
			/*  _________
			 *    	     |
			 *  	    O	
			 * 	    	 |		turns left before wall
			 */
			else if(sonars.hasHit(7) && !sonars.hasHit(4))
				robot.turn_left();
			//When front left is blocked, turn right (there's a gap in the wall on the front right)
			else if(sonars.hasHit(1) && !sonars.hasHit(7))
				robot.turn_right();
			//When front right is blocked, turn left (there's a gap in the wall on the front left)
			else if(sonars.hasHit(7) && !sonars.hasHit(1))
				robot.turn_left();
		}
	}

	//Controlling Spiraling Robot TODO works until object or wall encountered (could reset all variables and make OD_COUNT = robot's OD to restart spiral)
	public void control_spiral(Robot robot) {
		
		//After every 2nd right turn increase the distance the robot will travel by 0.5 before it will turn right again
		if(right_turns % 2 == 0 && right_turns != 0){
			right_turns = 0;
			distance_multiplier++;
			Odometer_count+=1;
		}
		//Compare value robot is supposed to travel to robot's Odometer and turn right once robot's Odometer reached expected value
		else if((robot.getOdometer() - Odometer_count >= 0.5)) {
			Odometer_count = Odometer_count + 0.5 * distance_multiplier;
			right_turns++;
			robot.turn_right();
		}
	}
	/**
	 * 
	 */
	private CentralStation() {
		//instantiating the robots array to hold maximum of 2 robots
		robots = new Robot[2];
		
		//instantiating array to store current position of robots as coordinates for maximum 2 robots
		robots_positions = new Coordinates[2];
		
		//Instantiating array with all possible behavior patterns
		behavior_patterns = new String[5];
		behavior_patterns[0] = "follow_wall";
		behavior_patterns[1] = "spiral";
		behavior_patterns[2] = "spiral_down";
		behavior_patterns[3] = "stop";
		behavior_patterns[4] = "found";
		
		//getting instance of File Server
		file_server = FileServer.getinstance();
		
	}

	/**
	 * 
	 */
	public void done_mapping() {
	}
	
	public void stop_mission() {
		robots[0].stop();
		robots[1].stop();
		robots[0].set_behavior(behavior_patterns[3]);
		robots[1].set_behavior(behavior_patterns[3]);
		System.out.println("Mission Stopped.");
	}
};