//--------------------------------------------------------
//Code generated by Papyrus Java
//--------------------------------------------------------

package main.java.softdesign;

import java.awt.image.BufferedImage;

import javax.vecmath.Vector3d;

import simbad.sim.RangeSensorBelt;

/************************************************************/
/**
* 
*/
public class CentralStation {
	/**
	 * 
	 */
	private Robot[] robots;
	/**
	 * 
	 */
	private static CentralStation centralStation = new CentralStation();
	/**
	 * 
	 */
	private static String[] behaviorPatterns;
	private Color objectColor;
	/**
	 * 
	 */
	private FileServer fileServer;
	/**
	 * 
	 */
	private Coordinates[] startingPositions;
	/**
	 * 
	 */
	private Color goalColor;
	/**
	 * 
	 */
	public static CentralStation getInstance() {
		return centralStation;
	}
	
	/**
	 * 
	 * @param position
	 * @param name
	 * @param count
	 */
	public Robot deployRobot(Vector3d position, String name) {
		//parse name to find robot's number
		int robotsNumber = Integer.parseInt(name.replaceAll("\\D", ""));
	
		//instantiate new robot and add it to the robots array
		robots[robotsNumber - 1] = new Robot(position, name);
		robots[robotsNumber - 1].initBehavior();

		//store robot's position
		startingPositions[robotsNumber - 1] = new Coordinates(position.x, position.z);
		
		//remove the robot's current position 
		fileServer.removeCoordinates(new Coordinates(position.x, position.z));
		return robots[robotsNumber - 1];
	}
	
	/**
	 * 
	 * @param color  
	 */
	public void startMission(Color color) {
		//Set each robot's behavior pattern
		robots[0].setBehavior(behaviorPatterns[0]);
		robots[1].setBehavior(behaviorPatterns[0]);
		goalColor = color; 
	}
	
	public boolean reachedStartingPositions(Coordinates coordinates) {
		for(int i = 0; i < startingPositions.length; i++){
			if(coordinates.x == startingPositions[i].x && coordinates.y == startingPositions[i].y)
				return true;
		}
		return false;
	}
	
	public void spiral(Robot robot, Coordinates coordinates, Coordinates prev) {
		Coordinates nextCoordinates = getNextCoordinates(coordinates, prev), left = getLeftCoordinates(coordinates, prev);

		if(fileServer.visited(new Coordinates(coordinates.x + 0.5, coordinates.y)) && fileServer.visited(new Coordinates(coordinates.x - 0.5, coordinates.y)) 
				&& fileServer.visited(new Coordinates(coordinates.x, coordinates.y + 0.5)) && fileServer.visited(new Coordinates(coordinates.x, coordinates.y - 0.5))) {
			cleanUp();       // NO CONGESTING, LET THEM BRAWL EACH OTHER AND MAY THE WINNER TAKE IT ALL
		} 
		else {
			if (!fileServer.visited(left))
				robot.turnLeft();
			else if (fileServer.visited(nextCoordinates))
				robot.turnRight();
		}
	}
	
	public void addBlocked(Coordinates coordinates, Coordinates prev) {
		fileServer.addBlocked(getLeftCoordinates(coordinates, prev));
	}
	
	//Give coordinate to move to for next spiral
	public void cleanUp() {
		System.out.println("Now Cleaning");
		
		//remove all unvisited coordinates that don't have any adjacent unvisited coordinates, since boxes need to occupy at least 2 adjacent coordinates
		for(double i = -12; i <= 12; i+=0.5) {
			for(double j = -12; j <= 12; j+=0.5) {
				Coordinates coordinates = new Coordinates(i,j);
				if(!fileServer.visited(coordinates)) {
					if(fileServer.visited(new Coordinates(i + 0.5, j)) && fileServer.visited(new Coordinates(i - 0.5, j)))
						fileServer.removeCoordinates(coordinates);
					else if(fileServer.visited(new Coordinates(i, j + 0.5)) && fileServer.visited(new Coordinates(i, j - 0.5)))
						fileServer.removeCoordinates(coordinates);
				}
			}
		}
		
		outerloop:
		for(double i = -12.5; i <= 12.5; i+=0.5) {  
			for(double j = -12.5; j <= 12.5; j+=0.5) {
				Coordinates coordinates = new Coordinates(i,j);
				if(!fileServer.visited(coordinates)) {
					robots[1].goal = coordinates;							//XXX Where to move to
					robots[1].setBehavior(behaviorPatterns[4]);
					robots[0].goal = coordinates;							//XXX Where to move to
					robots[0].setBehavior(behaviorPatterns[4]);
					System.out.println("Coordinate: " + i + " " + j);
					break outerloop;
				}
			}
			if(i == 12) {
				doneMapping();
			}
		}
	}
	
	//Checks if there is a blocked coordinate between robot and goal coordinate on x axis
	public boolean nothingBetween(Coordinates coordinates, Coordinates goal) {
		if(coordinates.y < goal.y) {
			for(double i = coordinates.y + 0.5; i < goal.y; i+=0.5) {
				if(fileServer.isblocked(new Coordinates(coordinates.x, i)))
					return false;
			}
		} else if(coordinates.y > goal.y) {
			for(double i = coordinates.y - 0.5; i > goal.y; i-=0.5) {
				if(fileServer.isblocked(new Coordinates(coordinates.x, i)))
					return false;
			}
		}
		
		return true;
	}
	
	/**
	 * 
	 * @param robot
	 * @param position
	 */
	public void updateCoordinates(Robot robot, Coordinates coordinates) {
		
		if (!fileServer.visited(coordinates))
			fileServer.removeCoordinates(coordinates);
				
	}
	
	private Coordinates getLeftCoordinates(Coordinates coordinates, Coordinates prev) {

		if(coordinates.x - prev.x > 0) 
			return new Coordinates(coordinates.x, coordinates.y - 0.5);
		else if(coordinates.x - prev.x < 0)
			return new Coordinates(coordinates.x, coordinates.y + 0.5);
		else if(coordinates.y - prev.y > 0)
			return new Coordinates(coordinates.x + 0.5, coordinates.y);
		else
			return new Coordinates(coordinates.x - 0.5, coordinates.y);
		
	}
	
	private Coordinates getNextCoordinates(Coordinates coordinates, Coordinates prev) {
	
		if(coordinates.x - prev.x > 0)
			return new Coordinates(coordinates.x + 0.5, coordinates.y);
		else if(coordinates.x - prev.x < 0)
			return new Coordinates(coordinates.x - 0.5, coordinates.y);
		else if(coordinates.y - prev.y > 0)
			return new Coordinates(coordinates.x, coordinates.y + 0.5);
		else
			return new Coordinates(coordinates.x, coordinates.y - 0.5);
		
	}
	
	//removes coordinates to left of robot from unvisited array
	public void removeLeftCoordinates(Coordinates coordinates, Coordinates prev) {
		Coordinates left, leftOfLeft;
		if(coordinates.x - prev.x > 0) {
			left = new Coordinates(coordinates.x, coordinates.y - 0.5);
			leftOfLeft = new Coordinates(coordinates.x, coordinates.y - 1.0);
		}
		else if(coordinates.x - prev.x < 0) {
			left = new Coordinates(coordinates.x, coordinates.y + 0.5);
			leftOfLeft = new Coordinates(coordinates.x, coordinates.y + 1.0);
		}
		else if(coordinates.y - prev.y > 0) {
			left = new Coordinates(coordinates.x + 0.5, coordinates.y);
			leftOfLeft = new Coordinates(coordinates.x + 1.0, coordinates.y);
		}
		else {
			left = new Coordinates(coordinates.x - 0.5, coordinates.y);
			leftOfLeft = new Coordinates(coordinates.x - 1.0, coordinates.y);
		}
			
		fileServer.removeCoordinates(left);
		
		if(leftOfLeft.x >= -12.5 && leftOfLeft.x <= 12.5 && leftOfLeft.y >= -12.5 && leftOfLeft.y <= 12.5 )
			fileServer.removeCoordinates(leftOfLeft);
	}

	public void mapObject(Coordinates[] coordinates) {
		
		//   OBJECT IN INVERTED SIMBAD AXIS (Origin,(vector) y, (vector) x)
		//
		//      x  _______
		//        |       | 
		//        | Object| length  
		//        |       |
		// origin |_______| y 
		//          width
		//
		Coordinates origin = coordinates[0], x = new Coordinates(0,0), y = new Coordinates(0,0);
		double length = 0, width = 0;
		int directionx, directiony;
		
		for (int i = 1; i < 4; i++) { // getting the values of x and y
			if(origin.x == coordinates[i].x) {
				x = coordinates[i];
				length = Math.abs(Math.abs(origin.y) - Math.abs(x.y));
			}
			if(origin.y == coordinates[i].y) {
				y = coordinates[i];
				width = Math.abs(Math.abs(origin.x) - Math.abs(y.x));
			}
		}
		
		
		directiony = origin.y > x.y ? -1 : 1;
		directionx = origin.x > y.x ? -1 : 1;
		
		Object object = new Object();
		
		for (double i = 0; i <= width; i+= 0.5){ // removing the coordinates occupied by the object from the unvisited array
			for (double j = 0; j <= length; j+=0.5){
				Coordinates newCoordinates = new Coordinates(origin.x +i * directionx, origin.y + j * directiony);
				fileServer.removeCoordinates(newCoordinates);
				fileServer.addBlocked(newCoordinates);
				object.addCoordinates(newCoordinates);
			}
		}
		object.setColor(objectColor);
		fileServer.addObject(object);
		
		if (goalColor.detectColor() == objectColor.detectColor())
			System.out.println("Found " + objectColor.detectColor() + " Object");
		

	}
	/**
	 * 
	 * @param coordinates 
	 * @param color 
	 * @return 
	 */
	public void foundObject(Coordinates coordinates, BufferedImage cameraImage) {
		
		int rgbValue = cameraImage.getRGB(cameraImage.getHeight() - 1, cameraImage.getWidth()/2);
		
		int blue = rgbValue & 0xff;
		int green = (rgbValue & 0xff00) >> 8;
		int red = (rgbValue & 0xff0000) >> 16;
		
		Color color = new Color(red,green,blue);
		
		objectColor = color;
	}
	
    public void isFree(Robot robot, Coordinates coordinates, Coordinates prev) {
    	Coordinates left = getLeftCoordinates(coordinates, prev);
    	Coordinates right;
    	
    	if(coordinates.x - prev.x > 0) 
			right = new Coordinates(coordinates.x, coordinates.y + 0.5);
		else if(coordinates.x - prev.x < 0)
			right = new Coordinates(coordinates.x, coordinates.y - 0.5);
		else if(coordinates.y - prev.y > 0)
			right = new Coordinates(coordinates.x - 0.5, coordinates.y);
		else
			right = new Coordinates(coordinates.x + 0.5, coordinates.y);
    	
    	if(!fileServer.visited(left))
    		robot.turnLeft();
    	else if(!fileServer.visited(right))
    		robot.turnRight();
    }
    
	public void foundObstacle(Robot robot, RangeSensorBelt sonars){
		
		//Hitting dead end 
		if (sonars.hasHit(2) && sonars.hasHit(6) && sonars.hasHit(0)){
			//If there's no space on either side, turn around
			if (sonars.getMeasurement(6) < 0.5 && sonars.getMeasurement(2) < 0.5)
				robot.turnAround();
			//if enough space on right, turn right
			else if (sonars.getMeasurement(6) > 0.5)
				robot.turnRight();
			//if enough space on left, turn left
			else if (sonars.getMeasurement(2) > 0.5)
				robot.turnLeft();
		}
		//When left is blocked, turn right
		else if (sonars.hasHit(2) && !sonars.hasHit(6)){
			robot.turnRight();
		}
		//When right is blocked, turn left
		else if (!sonars.hasHit(2) && sonars.hasHit(6)){
			robot.turnLeft();
		}
		//When front is blocked
		else if (!sonars.hasHit(2) && !sonars.hasHit(6))
		{	
			
			/*	    _________
			 * 	   |
			 * 	    O
			 * 	   |			turns right before wall
			 */
			if(sonars.hasHit(1) && !sonars.hasHit(4))
				robot.turnRight();
			
			/*  _________
			 *    	     |
			 *  	    O	
			 * 	    	 |		turns left before wall
			 */
			else if(sonars.hasHit(7) && !sonars.hasHit(4))
				robot.turnLeft();
			//When front left is blocked, turn right (there's a gap in the wall on the front right)
			else if(sonars.hasHit(1) && !sonars.hasHit(7))
				robot.turnRight();
			//When front right is blocked, turn left (there's a gap in the wall on the front left)
			else if(sonars.hasHit(7) && !sonars.hasHit(1))
				robot.turnLeft();
		}
	}

	/**
	 * 
	 */
	private CentralStation() {
		//instantiating the robots array to hold maximum of 2 robots
		robots = new Robot[2];
		
		//instantiating array to store current position of robots as coordinates for maximum 2 robots
		startingPositions = new Coordinates[2];
		
		//Instantiating array with all possible behavior patterns
		behaviorPatterns = new String[5];
		behaviorPatterns[0] = "followWall";
		behaviorPatterns[1] = "spiral";
		behaviorPatterns[2] = "stop";
		behaviorPatterns[3] = "finished";
		behaviorPatterns[4] = "moveTo";
		
		//getting instance of File Server
		fileServer = FileServer.getInstance();
		
	}

	/**
	 * 
	 */
	public void doneMapping() {
		robots[0].stop();
		robots[1].stop();
		robots[0].setBehavior(behaviorPatterns[2]);
		robots[1].setBehavior(behaviorPatterns[2]);
		fileServer.count();
	}
	
	public void stopMission() {
		robots[0].stop();
		robots[1].stop();
		robots[0].setBehavior(behaviorPatterns[2]);
		robots[1].setBehavior(behaviorPatterns[2]);
		System.out.println("Mission Stopped.");
	}
};